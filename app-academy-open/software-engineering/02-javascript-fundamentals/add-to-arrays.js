/*
    Write a function that takes a location, either "FRONT" or "BACK"
    and adds an element to either the front or back of the given
    array. If location is anything besides "FRONT" or "BACK",
    print an error. Your function should not return anything and
    should mutate the original array.

    (Hint: Look up the JavaScript functions: push/pop/shift/unshift)
*/
function addToArray(location, element, arr) {
  if (location === "FRONT") {
    arr.unshift(element);
  } else if (location === "BACK") {
    arr.push(element);
  } else {
    console.log("ERROR");
  }
}

/*
    Write a function range(min, max) that takes in two numbers.
    The function should return an array containing all numbers
    from min to max inclusive.

    Define this function using function expression syntax.
*/
const range = function (min, max) {
  const result = [];
  for (let i = min; i <= max; i++) {
    result.push(i);
  }
  return result;
};

/*
    Write a function evenNumbers(max) that takes in a number as an
    arg. The function should return an array containing all
    positive, even numbers that are less than max.

    Define this function using function expression syntax.
*/
const evenNumbers = function (max) {
  const result = [];
  for (let i = 2; i < max; i++) {
    if (i % 2 === 0) result.push(i);
  }
  return result;
};

/*
    Write a function logBetweenStepper(min, max, step) that takes
    in 3 numbers as parameters. The function should print out
     numbers between min and max at step intervals.
     See the following examples.

    Hint: this function only needs to print using console.log
    it does not need to return.
*/
const logBetweenStepper = (min, max, step) => {
  for (let i = min; i <= max; i += step) {
    console.log(i);
  }
};

/*
  Write a function factorsOf(num) that takes in a number as an arg.
  The method should return an array containing all positive numbers
  that are able to divide into num with no remainder.

  Define this function using function expression syntax.
*/
const isFactor = (factor, product) => product % factor === 0;

const factorsOf = function (max) {
  const results = [];
  for (let i = 1; i <= max; i++) {
    if (isFactor(i, max)) {
      results.push(i);
    }
  }
  return results;
};

/*
  Write a function fizzBuzz(max) that accepts a number as an arg.
  The function should return an array containing all positive
  numbers less than max that are divisible by either 3 or 5,
  but not both.
*/
const fizzBuzz = (max) => {
  const result = [];
  for (let i = 3; i < max; i++) {
    if ((i % 3 === 0 || i % 5 === 0) && !(i % 15 === 0)) {
      result.push(i);
    }
  }
  return result;
};

/*
    Write a function pitPat(max) that accepts a number as an arg.
    The function should return an array containing all positive
    numbers less than or equal to max that are divisible by either
    4 or 6, but not both.
*/
const pitPat = (max) => {
  const result = [];
  for (let i = 4; i <= max; i++) {
    if ((i % 4 === 0 || i % 6 === 0) && !(i % 12 === 0)) {
      result.push(i);
    }
  }
  return result;
};

/*
    Write a function doubleSequence that accepts a base and a
    length as arguments. The function should return an array
    representing a sequence that contains "length" elements.
    The first element of the sequence is always the "base", the
    subsequent elements can be generated by doubling the previous
    element of the sequence.
*/
const doubleSequence = (base, length) => {
  if (length === 0) return [];

  const result = [base];
  for (i = 0; i < length - 1; i++) {
    result.push(result[i] * 2);
  }
  return result;
};

/*
    Write a function tripleSequence that takes in two numbers,
    start and length. The function should return an array
    representing a sequence that begins with start and is
    length elements long. In the sequence, every element should
    be 3 times the previous element. Assume that the length
    is at least 1.
*/
const tripleSequence = (base, length) => {
  if (length === 0) return [];

  const result = [base];
  for (i = 0; i < length - 1; i++) {
    result.push(result[i] * 3);
  }
  return result;
};

/*
    Write a function unique that accepts an array as an argument.
    The function should return a new array containing elements
    of the input array, without duplicates.
*/
const unique = (arr) => arr.filter((ele, idx) => arr.indexOf(ele) === idx);

/*
    Write a function yeller(words) that takes in an array of words.
    The function should return a new array where each element of
    the original array is yelled.
*/
const yell = (word) => `${word.toUpperCase()}!`;
const yeller = (words) => words.map((word) => yell(word));

/*
    Write a function tripler(nums) that takes in an array as an arg.
    The function should return a new array containing three times
    every number of the original array.
*/
const tripler = (nums) => nums.map((num) => num * 3);

/*
    Write a function longWords(words) that takes in an array of
    words. The function should return an array containing only
    the words that are longer than 5 characters.
*/
const longWords = (words) => words.filter((word) => word.length > 5);

/*
    Write a function chooseyEndings that accepts an array of words
    and a suffix string as arguments. The function should return a
    new array containing the words that end in the given suffix. If
    the value passed in is not an array, return an empty array.

    HINT: There are built in JavaScript functions that will help
    with determining if a strings ends a certain way. Go see if
    you can find it on MDN!
*/
const chooseyEndings = (words, suffix) =>
  Array.isArray(words) ? words.filter((word) => word.endsWith(suffix)) : [];

/*
    Write a function commonFactors that accepts two numbers as
    arguments. The function should return an array containing
    positive numbers that are able to divide both arguments.
*/

// const isFactor = (factor, product) => product % factor === 0;

const commonFactors = (first, second) => {
  const factors = [];
  for (let i = 1; i < Math.max(first, second); i++) {
    if (isFactor(i, first) && isFactor(i, second)) {
      factors.push(i);
    }
  }
  return factors;
};

/*
    Write a function adjacentSums that accepts an array of numbers
    as an argument. The function should return a new array containing
    the sum of each pair of elements in the input array.
*/
const adjacentSums = (arr) => {
  const result = [];
  for (let i = 0; i < arr.length - 1; i++) {
    result.push(arr[i] + arr[i + 1]);
  }
  return result;
};

/*
    Write a function fibonacciSequence that accepts a number as an
    argument. The function should return an array representing the
    fibonacci sequence up to the given length. The first and second
    numbers of the sequence are 1 and 1. To generate subsequent
    numbers of the sequence, we take the sum of the previous two
    numbers of the sequence.
*/
function fibonacciSequence(length) {
  if (length === 0) return [];
  if (length === 1) return [1];
  if (length > 1) {
    const result = [1, 1];
    length -= 2;
    while (length > 0) {
      result.push(result[result.length - 1] + result[result.length - 2]);
      length--;
    }
    return result;
  }
}

/*
    Write a function pickPrimes that takes in an array of numbers
    and returns a new array containing only the prime numbers.
*/
const isPrime = (num) => {
  if (num < 2) return false;

  for (i = 2; i <= num; i++) {
    if (i !== num && num % i === 0) {
      return false;
    }
  }

  return true;
};
const pickPrimes = (arr) => arr.filter((ele) => isPrime(ele));

/*
    Write a function greatestFactorArray that takes in an array
    of numbers and returns a new array where every even number
    is replaced with it's greatest factor. A greatest factor is
    the largest number that divides another with no remainder.
    For example, the greatest factor of 16 is 8. (For the purpose
    of this problem we won't say the greatest factor of 16 is 16,
    because that would be too easy).
*/
// const isFactor = (factor, product) => product % factor === 0;

// const factorsOf = function (max) {
//   const results = [];
//   for (let i = 1; i <= max; i++) {
//     if (isFactor(i, max)) {
//       results.push(i);
//     }
//   }
//   return results;
// };
const greatestFactor = (num) =>
  factorsOf(num)
    .sort((a, b) => a > b)
    .pop();
const greatestFactorArray = (array) =>
  array.map((ele) => {
    const greatest = greatestFactor(ele);
    // note: the instructions are misleading on this,
    // and I bug reported it.
    // per the instructions: the greatest factor of 16 is 8
    // which would imply that the greatest factor of a number
    // cannot be that number itself. However, the expected
    // output requires that the greatest factor of a number
    // be that number itself if it is prime.
    return greatest === 1 ? ele : greatest;
  });

/*
      A number's summation is the sum of all positive numbers
      less than or equal to the number. For example: the
      summation of 3 is 6 because 1 + 2 + 3 = 6, the summation
      of 6 is 21 because 1 + 2 + 3 + 4 + 5 + 6 = 21. Write a
      function summationSequence that takes in two numbers:
      start and length. The function should return an array
      containing length total elements. The first number of
      the sequence should be the start number. At any point,
      to generate the next element of the sequence we take
      the summation of the previous element. You can assume that
      length is not zero.
  */
const summation = (num) => {
  let result = 0;
  for (let i = 0; i <= num; i++) {
    result += i;
  }
  return result;
};
const summationSequence = (start, length) => {
  const result = [start];
  for (let i = 1; i < length; i++) {
    result.push(summation(result[i - 1]));
  }
  return result;
};
